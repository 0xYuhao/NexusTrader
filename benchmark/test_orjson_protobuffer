import time
import orjson
import json
from google.protobuf import json_format
import trade_data_pb2  # 假设我们已经定义了 Protocol Buffers 消息


def generate_trade_data(num_trades):
    return {
        "timestamp": int(time.time()),
        "trades": [
            {
                "symbol": f"STOCK_{i}",
                "price": 100.0 + i,
                "volume": 1000 + i * 10,
                "side": "BUY" if i % 2 == 0 else "SELL",
            }
            for i in range(num_trades)
        ],
    }


def benchmark_orjson(data, num_iterations):
    start_time = time.time()
    for _ in range(num_iterations):
        serialized = orjson.dumps(data)
        deserialized = orjson.loads(serialized)
    end_time = time.time()
    return end_time - start_time


def benchmark_protobuf(data, num_iterations):
    start_time = time.time()
    trade_list = trade_data_pb2.TradeList()
    deserialized = trade_data_pb2.TradeList()

    for trade in data["trades"]:
        pb_trade = trade_list.trades.add()
        pb_trade.symbol = trade["symbol"]
        pb_trade.price = trade["price"]
        pb_trade.volume = trade["volume"]
        pb_trade.side = trade["side"]
    trade_list.timestamp = data["timestamp"]

    for _ in range(num_iterations):
        # json_format.Parse(json.dumps(data), trade_list)
        serialized = trade_list.SerializeToString()
        deserialized.ParseFromString(serialized)
    end_time = time.time()
    return end_time - start_time


def run_benchmark(num_trades, num_iterations):
    data = generate_trade_data(num_trades)

    orjson_time = benchmark_orjson(data, num_iterations)
    protobuf_time = benchmark_protobuf(data, num_iterations)

    print(f"Number of trades: {num_trades}")
    print(f"Number of iterations: {num_iterations}")
    print(f"orjson time: {orjson_time:.4f} seconds")
    print(f"protobuf time: {protobuf_time:.4f} seconds")
    print(f"orjson is {protobuf_time / orjson_time:.2f}x faster than protobuf")


if __name__ == "__main__":
    run_benchmark(num_trades=10000, num_iterations=1000)
